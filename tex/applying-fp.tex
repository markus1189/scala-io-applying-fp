\documentclass{beamer}

\usepackage{minted}
\usepackage{pgf}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}

\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}

\title{Applying \textbf{one} FP Pattern: Monoids}
\subtitle{Original Title: Applying FP Patterns}
\author{Markus Hauck}
\date{Scala.IO, 2016}
\subject{Computer Science}

\input{./beamer-setup}

\renewcommand\texttt[1]{\mintinline{scala}/#1/}

\begin{document}
\frame{\titlepage}

\section{Intro}
\label{sec:intro}

\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
  \item many new useful patterns in FP
  \item today: Monoids
  \item after enlightenment, apply this with Apache Spark
  \end{itemize}
\end{frame}

\section{Composition}

\begin{frame}
  \frametitle{Lego vs Duplo}
  \begin{center}
    \includegraphics[width=0.45\textwidth]{../images/duplo-construction.jpg}
    \hspace{1mm}
    \includegraphics[width=0.45\textwidth]{../images/duplo-airport.jpg}
  \end{center}
  \vfill
  \begin{center}
    {\tiny pictures from \url{shop.lego.com}}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Lego vs Duplo}
  \begin{center}
    \includegraphics[width=0.45\textwidth]{../images/lego-sydney-opera.jpg}
    \includegraphics[width=0.45\textwidth]{../images/lego-tower-bridge.jpg}
  \end{center}
  \vfill
  \begin{center}
    {\tiny pictures from \url{shop.lego.com}}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Lego vs Duplo}
  \begin{itemize}
  \item Duplo favours specialized building blocks that do
    \textbf{not} compose
  \item therefore very limited reuse, blocks tend to be too big
  \item Lego on the other side focuses on small composable building
    blocks
  \item blocks can conveniently be reused for other purposes
  \item limited use of specialized building blocks
  \item OO tends to be like Duplo, FP tends to be like Lego
  \end{itemize}
\end{frame}

\section{Monoids}

\begin{frame}
  \frametitle{Monoids}
  \begin{itemize}
  \item intuition: ``combine stuff''
  \item you can create values from thin air via \texttt{Monoid.empty}
  \item combine two values via \texttt{Monoid.combine} / \texttt{|+|}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoid Laws}
\begin{minted}{scala}
// 1) left identity
empty |+| x === x

// 2) right identity
x |+| empty === x

// 3) associative
x |+| (y |+| z) === (x |+| y) |+| z
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoid Typeclass}
\begin{minted}{scala}
trait Monoid[A] {
  def empty: A
  def combine(lhs: A, rhs: A): A
  // infix operator: |+|
}

implicit val plus: Monoid[Int] = new Monoid[Int] {
  def empty: Int = 0
  def combine(lhs: Int, rhs: Int): Int =
    lhs + rhs
}
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{More Monoids}
  \begin{itemize}
  \item \texttt{Monoid} instance not unique: addition / multiplication / min / max
  \item most collections are \texttt{Monoid}s: \texttt{List} / \texttt{Vector} / \texttt{Set}
  \item let's see some more examples
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Monoid Zoo}
  \begin{tabular}{p{5cm} l}
    \texttt{A => B} & if \texttt{B} is a \texttt{Monoid} \\
    \only<2->{\texttt{(A,B)} & if \texttt{A} \textbf{and} \texttt{B} are \texttt{Monoid}s \\}
    \only<3->{\texttt{List[A]} & if \texttt{A} is a \texttt{Monoid} \\}
    \only<4->{\texttt{Future[A]} & if \texttt{A} is a \texttt{Monoid} \\}
    \only<5->{\texttt{Map[A,B]} & if \texttt{B} is a \texttt{Monoid}}
  \end{tabular}
  \onslide<6->
\begin{minted}{scala}
val m1 = Map("as" -> 21, "bs" -> 4)
val m2 = Map("as" -> 21, "cs" -> 2)
m1 |+| m2
//  Map("as" -> 42, "bs" -> 4, "cs" -> 2)
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoids Compose (Lego Principle)}
  \onslide<1->
\begin{minted}{scala}
Config => A
\end{minted}
  \onslide<2->
\begin{minted}{scala}
Config => Future[A]
\end{minted}
  \onslide<3->
\begin{minted}{scala}
Config => Future[Map[String,A]]
\end{minted}
  \onslide<4->
\begin{minted}{scala}
Config => Future[Map[String,(A,B)]]
\end{minted}
  \onslide<5->
\begin{minted}{scala}
Config => Future[Map[String,(A,Option[B])]]
\end{minted}
  \onslide<6->
\begin{minted}{scala}
Config => Future[Map[String,(Set[A],Option[B])]]
\end{minted}
\end{frame}

\section{Apache Spark}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../images/disapproval.jpg}
  \end{center}
  \begin{center}
    {\large I thought this was about \textbf{applying} patterns!}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{../images/spark-logo-trademark.png}
  \end{center}

  \begin{itemize}
  \item analysis of a potentially huge text
  \item calculate metrics over text
    \begin{itemize}
    \item word count
    \item char count
    \item min/max word length
    \item avg word length
    \item \dots (be flexible)
    \end{itemize}
  \item \textbf{goal}: single traversal $\leftrightarrow$ \textbf{easy} composition
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RDDs and Folds}
\begin{minted}{scala}
abstract class RDD[T] {
  /**
   * Aggregate the elements of each partition,
   * and then the results for all the partitions,
   * using a given associative function and a
   * neutral "zero value".
   */
  def fold(zeroValue: T)(op: (T, T) => T): T
}
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoidal RDDs}
\begin{minted}{scala}
implicit class MonoidRDD[T](val rdd: RDD[T]) {

  // avoid conflicts with fold/reduce etc
  def combine(implicit M: Monoid[T]): T =
    rdd.fold(M.empty)(M.combine(_,_))

}
\end{minted}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{The Program}
\begin{minted}{scala}
val sc: SparkContext = ???
val file: String = ???

val data = sc.textFile(file).
  flatMap(_.split("""\W+""")).
  map(expand)

def expand(w: String) = (1, w.length, Map(w -> 1))

val (words,chars,wordMap) = data.combine
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Running this program}
\begin{minted}{text}
Scala.io The Scala event in France
\end{minted}
  \onslide<2->
\begin{minted}{scala}
Seq("Scala","io","The","Scala","event","in",...)
\end{minted}
  \onslide<3->
\begin{minted}{scala}
Seq(
  (1, 5, Map("Scala" -> 1)),
  (1, 2, Map("io" -> 1)),
  (1, 3, Map("The" -> 1)),
  (1, 5, Map("Scala" -> 1)),
  // ...
)
\end{minted}
  \onslide<4->
\begin{minted}{scala}
(6,29,Map("Scala" -> 2,"io" -> 1,"The" -> 1,...))
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Easy Extension}
\begin{minted}{scala}
val data: RDD[String] = ??? // as before

def expand(w: String) = (
  1,
  w.length,
  Map(w -> 1),
  Max(w.length),           // max word length
  Min(w.length),           // min word length
  Map(w.length -> Set(w))) // words by count

val (words,chars,wordMap) = data.combine
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The new program}
\begin{minted}{text}
Scala.io The Scala event in France
\end{minted}
  \onslide<2->
\begin{minted}{scala}
Seq("Scala","io","The","Scala","event","in",...)
\end{minted}
  \onslide<3->
\begin{minted}{scala}
Seq(
  (1, 5, Map("Scala" -> 1)),
  (1, 2, Map("io" -> 1)),
  (1, 3, Map("The" -> 1)),
  (1, 5, Map("Scala" -> 1)),
  // ...
)
\end{minted}
  \onslide<4->
\begin{minted}{scala}
(6,29,Map("Scala" -> 2,"io" -> 1,"The" -> 1,...))
\end{minted}
\end{frame}

\section{Almost Done}

\begin{frame}
  \frametitle{More Monoid Tricks}
  \begin{itemize}
  \item ``filter'' values via \texttt{mempty} value
  \item map + reduce == two phase computation via monoids
  \item finger trees, implement multiple data structures using monoids
  \item drawing diagrams (haskell)
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[height=2cm]{../images/duplo-logo} \hspace{2cm} \includegraphics[height=2cm]{../images/lego-logo}.
  \end{center}
\end{frame}

\end{document}
