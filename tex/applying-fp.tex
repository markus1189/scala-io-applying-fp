\documentclass{beamer}

\usepackage{minted}
\usepackage{pgf}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}

\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}

\title{Applying \textbf{one} FP Pattern: Monoids}
\subtitle{Original Title: Applying FP Patterns (sorry)}
\author{Markus Hauck}
\date{Scala.IO, 2016}
\subject{Computer Science}

\input{./beamer-setup}

\renewcommand\texttt[1]{\mintinline{scala}/#1/}

\begin{document}
\frame{\titlepage}

\section{Intro}
\label{sec:intro}

\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
  \item many new useful patterns in FP
  \item today: Monoids
  \item after enlightenment, apply this with Apache Spark
  \end{itemize}
\end{frame}

\section{Composition}

\begin{frame}
  \frametitle{Lego vs Duplo}
  FP = Lego, OO = Duplo?
\end{frame}

\section{Monoids}

\begin{frame}
  \frametitle{Monoids}
  \begin{itemize}
  \item intuition: ``combine stuff''
  \item you can create values from thin air via \texttt{Monoid.empty}
  \item combine two values via \texttt{Monoid.combine} / \texttt{|+|}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoid Laws}
\begin{minted}{scala}
// 1) left identity
empty |+| x === x

// 2) right identity
x |+| empty === x

// 3) associative
x |+| (y |+| z) === (x |+| y) |+| z
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoid Typeclass}
\begin{minted}{scala}
trait Monoid[A] {
  def empty: A
  def combine(lhs: A, rhs: A): A
}

implicit val intPlus: Monoid[Int] = {
  new Monoid[Int] {
    def empty: Int = 0
    def combine(lhs: Int, rhs: Int): Int =
      lhs + rhs
  }
}
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{More Monoids}
  \begin{itemize}
  \item Numeric types with addition / multiplication
  \item \texttt{List}/\texttt{Vector}/\texttt{Set}
  \item lots of others...
  \item more important: composes nicely like legos
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Monoids Compose (Lego Principle)}
  \begin{tabular}{l l}
    \texttt{Map[A,B]} & if \texttt{B} is a \texttt{Monoid} \\
    \texttt{A => B} & if \texttt{B} is a \texttt{Monoid} \\
    \texttt{Future[A]} & if \texttt{A} is a \texttt{Monoid} \\
    \texttt{(A,B)} & if \texttt{A} \textbf{and} \texttt{B} are \texttt{Monoid}s \\
    \texttt{A => Future[Map[K,(V1,V2)]]} & if ?
  \end{tabular}

\begin{minted}{scala}
val m1 = Map("as" -> 21, "bs" -> 4)
val m2 = Map("as" -> 21, "cs" -> 2)
m1 |+| m2
//  Map("as" -> 42, "bs" -> 4, "cs" -> 2)
\end{minted}
\end{frame}

\section{Apache Spark}

\begin{frame}
  \begin{center}
    % \includegraphics[width=0.6\textwidth]{../images/futurama-fry.jpg}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Apache Spark}
  \begin{itemize}
  \item Apache Spark:
    \begin{itemize}
    \item analysis of a text (huuuuge)
    \item run in cluster
    \end{itemize}
  \item some possible metrics over text
    \begin{itemize}
    \item word count
    \item char count
    \item min/max word length
    \item avg word length
    \item \dots (be flexible)
    \end{itemize}
  \item \textbf{goal}: single traversal $\leftrightarrow$ \textbf{easy} composition
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RDDs and Folds}
\begin{minted}{scala}
abstract class RDD[T] {
  /**
   * Aggregate the elements of each partition,
   * and then the results for all the partitions,
   * using a given associative function and a
   * neutral "zero value".
   */
  def fold(zeroValue: T)(op: (T, T) => T): T
}
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoidal RDDs}
\begin{minted}{scala}
implicit class MonoidRDD[T](val rdd: RDD[T])
  extends AnyVal {

  // avoid conflicts with fold/reduce etc
  def combine(implicit M: Monoid[T]): T =
    rdd.fold(M.empty)(M.combine(_,_))

}
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using Monoids}
  \begin{itemize}
  \item monoids are perfect for this
  \item all we need from Spark is the \texttt{fold} function on \texttt{RDD}s
  \end{itemize}
\begin{minted}{scala}
foo bar baz
\end{minted}
\end{frame}

% IDEA: use the `animate' package to show animations

\section{Almost Done}

\begin{frame}
  \frametitle{More Monoid Tricks}
  \begin{itemize}
  \item ``filter'' values via \texttt{mempty} value
  \item map + reduce == two phase computation via monoids
  \item finger trees, implement multiple data structures using monoids
  \item drawing diagrams (haskell)
  \end{itemize}
\end{frame}

\end{document}
